package Anagram;
# vim: noet:

use 5.016;
use warnings;
use open qw(:utf8 :std);

=encoding UTF8

=head1 SYNOPSIS

Поиск анаграмм

=head1 anagram($arrayref)

Функция поиска всех множеств анаграмм по словарю.

Входные данные для функции: ссылка на массив - каждый элемент которого - слово на русском языке в кодировке utf8

Выходные данные: Ссылка на хеш множеств анаграмм.

Ключ - первое встретившееся в словаре слово из множества
Значение - ссылка на массив, каждый элемент которого слово из множества, в том порядке в котором оно встретилось в словаре в первый раз.

Множества из одного элемента не должны попасть в результат.

Все слова должны быть приведены к нижнему регистру.
В результирующем множестве каждое слово должно встречаться только один раз.
Например

anagram(['пятак', 'ЛиСток', 'пятка', 'стул', 'ПяТаК', 'слиток', 'тяпка', 'столик', 'слиток'])

должен вернуть ссылку на хеш

{
	'пятак'  => ['пятак', 'пятка', 'тяпка'],
	'листок' => ['листок', 'слиток', 'столик'],
}

=cut

sub anagram {
	my $words_list = shift;
	my %result;

	use POSIX qw(strftime);
	# Get current datatime
	my $last_time_start = strftime "%Y-%m-%d %H:%M:%S\n", localtime;

	#
	# Поиск анаграмм
	#
	# перебираем элементы списка(разименовывая ссылку на массив)
	foreach (@{$words_list}) {
		if (ref $_ ne "ARRAY") {
			# если в строке всего одно слово делаем из него ссылку на это слово
			$_ = [$_];
		}
		foreach (@{$_}) {
			# разбиваем слово на буквы
			my @word = split "", fc($_);
			# входим в хеш (до этого установив флаг сходства по хешу не найдено)
			my $found_f = 0;
			for my $key (keys %result) {
				# проверяем на полное равенство и если полностью равны просто берем следующее слово
				if (fc($key) eq fc($_)) {
					$found_f = 1;
					last;
				}
				# если являются анаграммами, то добавляем в массив и ставим флаг
				if (CheckAnagram($key, @word)) {
					$found_f = 1;
					# Проверяем на наличие записи в массиве
					my $found = 0;
					for my $val (@{$result{"$key"}}) {
						if (fc($val) eq fc($_)) {
							$found = 1;
							last;
						}
					}
					unless ($found) {
						push @{$result{"$key"}}, fc($_);
					}
				}
			}
			# если в итоге поиска по хешу мы не нашли куда поместить наше слово(список анаграмм))
			unless ($found_f) {
				# инициализируем cсылкой на массив
				$result{"\F$_\E"} = ["\F$_\E"];
			}
		}
	}
	
	# переносим все нужное в результирующий хеш
	my %pastresult;
	while (my ($k, $v) = each %result) {
		if (@{$v} != 1) {
			$pastresult{$k} = $v;
		}
	}	

	# Get current datatime
	my $last_time_end = strftime "%Y-%m-%d %H:%M:%S\n", localtime;

	print "Start Script ".$last_time_start."\n";
	print "End Script ".$last_time_end."\n";

	return \%pastresult;
}

# функция проверки являются ли переданные слова анаграммами
# принимает на вход - слова для сравнения (первое словом, сторое массивом букв)
# выдает на выход являются ли слова анаграммами (0 - да, 1 - нет)
sub CheckAnagram (\$\@) {
	# получаем слова для сравнения, одно словом, другое массивом букв
	my ($patt, @word) = @_;

	# разбиваем слово на буквы
	my @patt = split "", fc($patt);

	# проверяем на равенство количества символов
	if (@patt != @word) {
		# Если длины не равны - слова не анаграммы
		return 0;
	}

	# считаем количество букв в каждом слове
	my %patt = %{ GetCountOfLetters(@patt) };
	my %word = %{ GetCountOfLetters(@word) };

	# пробегаемся по первому хешу и сравниваем ключи и значения со вторым
	while (my ($k, $v) = each %patt) {
		# если ключа нет в хеше, или значение по ключу не соответствует ожидаемому
		unless (exists $word{$k} and $word{$k} == $v) {
			return 0;
		}
	}

	# в конце если все условия пройдены вернем что данные слова являются анаграммами
	return 1;
}

# получает на вход массив букв
# на выход выдает хеш {"буква" => вхождений} 
sub GetCountOfLetters (\@) {
	my (@word) = @_;
	# создаем хеш для букв и перебираем буквы слова
	my %letters;
	foreach (@word) {
		if (exists $letters{$_}) {
			# если буква уже есть в хеше то делаем inc
			$letters{$_}++;
		}
		else {
			# иначе добавляем букву в первый раз
			$letters{$_} = 1;
		}
	}
	# возвращаем ссылку на хеш букв
	return \%letters;
}

1;
