Мастер класс WEB-ПРИЛОЖЕНИЕ
===========================

Ссылка на мастер класс
===========================
https://www.youtube.com/watch?v=p9nzKKmBwJc&t=6s


Текстовое содержимое
===========================
Мастер класс по созданию нового web-приложения.
===========================
Представим ситуацию, к нам приходит менеджер и просит нас:
* создать ресурс для возможности обмена текстовыми файлами тыкая пальцем на пастбин
* название выбирается `fastpaste`
* за один раз можно отправить не более 10 кб текста
* при отправке текста пользователь получает уникальную ссылку на этот текст, которой он может в будущем поделиться с кем угодно и все могут посмотреть на этот текст
* пользователь может указать(опционально) название размещаемого текста и время его хранения, после того как время хранения выйдет если оно указано, то необходимо удалить запись из базы, если же время не указано, то запись должна храниться всегда
* Также на всех страницах ресурса должны быть ссылки на последние 10 размещенных текстов 

`Собственно все пока довольно просто и прозрачно, никакой регистрации, все полностью анонимно, главное разобраться с технологией.`

----------------------
Итак выберем средства которые мы будем использовать:
* для хранения метаданных я буду использовать: mysql
* для хранения непосредственно текстов я буду использовать: файловую систему, т.е. файлы
* для формирования уникальных ссылок я буду использовать: 64 битные числа, дабы их нельзя было перебрать по порядку, формировать я их буду при помощи алгоритма `CRC64`, в него буду передавать непосредственно контент и время размещения
* для создания web-приложения я буду использовать фреймворк Dancer2
* для шаблонизации я буду использовать шаблонизатор Template Toolkit

`Соответственно о настройке mysql я ничего сейчас рассказывать не буду. Для установки, настройки и его запуска никаких дополнительных хитростей не требуется, просто качаете дистрибутив, устанавливаете и действуете по инструкции с сайта mysql.`

----------------------
Начнем с установки модулей:
Итак как я уже говорил нам понадобятся модули
* `Dancer2`     - непосредственно фреймворк на котором мы будем создавать приложение
* `Digest::CRC` - для подсчета контрольной суммы и получения уникальной ссылки
* `Dancer2::Plugin::Database` - для подключения базы данных к фреймворку Dancer2
* `DBD::mysql`  - непосредственно драйвер для подключения к самому mysql
* `HTML::Entities` - для экранирования специальных HTML-символов в пользовательском тексте чтобы не получить на выходе XSS.

`Так все модули у меня установлены уже, все последней версии, о чем CPAN мне с радостью и сообщил.`

# Код в терминал (Некоторые способы установки)
```
sudo cpan install Dancer2 Digest::CRC Dancer2::Plugin::Database DBD::mysql HTML::Entities
```
или
```
sudo cpanm Dancer2 Digest::CRC Dancer2::Plugin::Database DBD::mysql HTML::Entities
```

----------------------
Теперь перейдем к настройке базы данных.
----------------------
Для начала создадим саму базу данных и пользователя для нашего проекта.
# Код в терминал (запуск mysql)
```
/usr/local/mysql/bin/mysql -u root -p
```

`У меня mysql лежит по вот такому не заурядному пути,`

* я авторизуюсь при помощи суперюзера root mysql
* создаю базу данных, везде буду использовать имя `fastpaste`, для того чтобы не путаться, ну и конечно же везде указываю charset utf8 потому что так как проект у нас будет русский и если его не указать мы получим потом кашу вместо русских utf'ных символов.
`Так, база данных создана,`
* создадим юзера с таким же паролем `fastpaste` как его имя
* и дадим этому пользователю права на созданную нами базу данных
`Все, права выданы`

# Код в терминал mysql (создание базы, пользователя и выдача всех прав на созданную базу)
```
create database fastpaste charset utf8;
create user fastpaste IDENTIFIED BY 'fastpaste';
GRANT ALL ON fastpaste.* to fastpaste;
```
Разлогиниваюсь теперь из под root'а. (ctrl+D)

----------------------
Теперь логинимся пользователем `fastpaste`, указываем что мы хотим подключиться к базе данных `fastpaste`, вводим пароль `fastpaste`.
# Код в терминал (запуск mysql)
```
/usr/local/mysql/bin/mysql -u fastpaste -p fastpaste
```
Видим что нас mysql пустил в нашу новосозданную базу данных, теперь подумаем о том какая таблица нам там понадобится.
Так как у нас пока никакой авторизации пока нет, будем хранить пока только метаданные.
`В этой таблице нам понадобится уникальный идентификатор колоночка в которой будет храниться идентификатор, это 64 битное число, будем сразу по ходу писать, `
Табличку назовем `paste`: 
* значит идентификатор нам нужен `id`, у нас это bigint так как 64 битный int в mysql называется bigint, он не может быть Null'ом и он должен быть Primary key'ем 
* соответственно нам еще нужен `create time`, нужен он нам для того чтобы по нему выбирать последние созданные, это у нас имеет тип `timestamp`, он не может быть у нас Null'ом так как время создания всегда обязательно должно быть
* у нас возможно будет указан опционально `expire_time`, это у нас имеет тип `timestamp`, он может быть Null'ом
* также у нас опционально может быть указано название `title`, так как не сказано какой длины будет название сделаем `varchar(255)`, т.е. не больше чем 255 байт либо 128 русских utf'ных символов, либо еще меньше utf'ных символов, выборки нам делать не надо, поэтому никаких индексов, ничего не строим по этой колонке.
* теперь так как мы будем выбирать по `create_time` нам нужен индекс по нему
* также нам нужен индекс по `expire_time`, нужен он нам для того чтобы вычищать старые, про'expire'енные записи
и не забываем указывать кодировку.

=head2
  id - уникальный код записи (64 бит число),
  create_time - время создания (время),
  expire_time - время жизни (время),
  create_time_idx - индекс по времени создания (основной параметр для поиска)
  expire_time_idx - индекс по времени жизни    (для того чтобы вычищать старые заметки)
=cut
# Код в терминал mysql (создание таблицы)
```
CREATE TABLE paste (
	id BIGINT PRIMARY KEY NOT NULL,
	create_time TIMESTAMP NOT NULL,
	expire_time TIMESTAMP NULL,
	title VARCHAR(255),
	index create_time_idx (create_time),
	index expire_time_idx (expire_time)
) charset utf8;
```

`Ура табличка наша создана, проверим`
# Код в терминал mysql (проверка)
```
show tables;
show create table paste;
```
`Да, да, Видим что у нас есть наши Primary Key, ключ(индекс) по create_time по expire_time, все колонки как мы указывали.`
Особенность mysql еще в том, что первая колонка timestamp указанная в нашей таблице в себя принимает Default значение Current_timestamp

На этом работа с базой данных у нас закончена. (ctrl+D)

----------------------
Теперь говорим построить нам приложение под названием `fastpaste` на основе движка Dancer2.
# Код в терминал (строим приложение на основе движка Dancer2 и переходим во вновь полученный каталог)
```
dancer2 -a fastpaste
cd fastpaste
```
Dancer2 потрудился, сделал нам каркас нашего приложения, соответственно зайдем в созданную папку `fastpaste`.
Отредактируем сразу же `config.yml`:
* Собственно `appname` `layout` `charset`, не трогаем, это все как и надо
* договорились использовать `template_toolkit`, это значит `template simple` мы комментируем, а все что связано с `template_toolkit` комментарии снимаем
* `start_tag` `end_tag` специально переопределим (потому что по-умолчанию в `template_toolkit` start_tag = "|%"  end_tag = "%|"), но так как все шаблоны внутри Dancer'а уже написаны с тегами "угловыми скобочками"(< >), специально оставляем угловые скобочки чтобы меньше шаблонов перелопачивать, потому что за основу мы будет брать шаблоны уже написанные на Dancer'е

# Код с которого нужно снять комментарий
```
template: "template_toolkit"
engines:
  template:
    template_toolkit:
      start_tag: '<%'
      end_tag:   '%>'
```

соответственно теперь подключим нашу базу данных:
* драйвер мы используем `mysql`, 
* база данных у нас `fastpaste`, 
* хост у нас `localhost`, так как база данных запущена на этой же машине, 
* порт стандартный mysql'ный `3306`, 
* потом нам надо указать username он у нас тоже `fastpaste` 
* и password аналогично, 
* укажем некоторые dbi_params'ы для DBD::mysql'я, более подробно о них можно почитать по документации по DBI, работать мы будет бех транзакций, поэтому делаем сразу же `AutoCommit`, 
* после подключения к базе данных сразу выполним несколько запросов `on_connect_do`, это нужно для того чтобы заработал utf8 на всех версия базы данных mysql, 
* ну и чтобы было проше нам отлаживаться сразу же включаем `log_queries`, чтобы все query(запросы) которые мы выполняем к базе логировались в файлик, тогда мы сможем посмотреть чтоже происходит с нашим приложением.

# Код который нужно добавить в конец файла config.yml (конфигурирование)
```
plugins:
  Database:
    driver: 'mysql'
    database: 'fastpaste'
    host: 'localhost'
    port: 3306
    username: 'fastpaste'
    password: 'fastpaste'
    dbi_params:
      RaiseError: 1
      AutoCommit: 1
    on_connect_do: ["SET NAMES 'utf8'", "SET CHARSET SET 'utf8'"]
    log_queries: 1
```

'DJPМОЖНО ВЫШЕ ОШИБКА -> "SET CHARACTER SET 'utf8'" вместо `"SET CHARSET SET 'utf8'"` '

Соответственно так как мы решили хранить тексты непосредственно в файлах, нужно для этого создать директорию.
Я буду создавать директорию непосредственно внутри самого проекта, назову её `paste` по аналогии с табличкой.
# Код в терминал (создаем каталог paste для хранения файлов)
```
mkdir paste
```
`Однако если это будет какой-то продакшн ресурс наверняка эту директорию надо будет создать на отдельно имплементированном диске каком-то чтобы разбалансировать нагрузку или на нескольких дисках, ну в общем пока об этом не будем, нас интересуют непосредственно технологии`

----------------------
Итак, в этот момент у нас подготовка завершена, можно начинать писать код нашего приложения.
Соответственно так как наше приложение должно хоть как нибудь быть оформлено нам нужны будут стили и шаблоны.
`За основу я буду брать стили от самого Dancer'а, т.е. от того что Dancer нам предоставил и немного добавлю стилей из другого тестового проекта, чтобы не смешать акцент от перла и не рассказывать сейчас про css'ки, у меня такие стили лежат в некотором файлике,`
`стили храняться в папочке public, значит мы их сюда и скопируем` 
# копируем стили и папки ~/... в папку public/css/
# cp ~/... public/css/
Соответственно стили мы сюда положили, разбираться в том что написано в стилях я сейчас не буду, будем читать что они нормальные и такие как нам надо.

Для начала нам нужно подправить наш `layout`, открываем views/layouts/main.tt
# vim views/layouts/main.tt
Это layout идущий по умолчанию, мы здесь имеем некоторое количество кода, который уже сгенерировал нам Dancer, мы видем подключение css'а стандартного который есть в Dancer'е, добавим туда подключение еще нашего css'а.
# Код в main.tt, добавить после строки "<link rel="stylesheet" href="<% request.uri_base %>/css/style.css">"##
#<link rel="stylesheet" href="<% request.uri_base %>/css/Скопированный вами.css">
Дальше по коду у нас подгрузка jquery, соответственно если не смогли загрузить из сети оно попробует загрузить локально, ничего не трогаем оставляем как есть.
</head> наш закончился.
Dancer внутри <body> сразу же пишет `content` своих страниц, у нас же обвязка будет чуть чуть побольше.
Мы будем давать обвязку в виде основного блока и блока с правой стороны - это последние 10 загруженных текстов, так было указано в нашем ТЗ.
* Я создам сначала слой для самой страницы (<div id="page">)
* Затем я создам слой для `sidebar` (<div id="sidebar">)
* внутри `sidebar` у нас будет наш списочек с последними загруженными текстами (<ul id="sidebar-items"></ul>), но давайте мы пока не будем про список, мы пока не знаем что к нам придет, пока просто забили место где они будут.
`Наш sidebar закончился`
* следующий слой, это слой с непосредственно нашим контентом, так и назовём его `content`
* внутри контента у нас будет наш `header` - заголовочек, (<div id="header">)
* завернем `header` еще и в <h1> чтобы поисковиками лучше индексироваться (<h1><a href="/">Fast Paste</a></h1>)
* скорее всего наше название(`header`) должно быть кликабельным, поэтому это должна быть ссылка на корень сайта
* было бы неплохо еще поприветствовать пользователя (<h2>Welcome!</h2>)
`На этом header заканчивается`
* следом будет наш слой контента, я буду использовать стиль который был в Dancer'е, у него неплохая сразу же разбивка там изначально
`Если вы ставили Dancer И пробовали генерировать default приложения, вы видели что у него по центру идёт серая часть непосредственно с информацией и справа сайдбар со ссылками и документацией` 
Мы будем использовать точно такое же расположение, в центральной части наш текст и наша форма для ввода нового текста или показа вышесохраненного, а сайдбар в котором размещена документация там мы будем показывать последние отправленные к нам тексты
непосредственно внутри `getting-started`мы уже и будем отображать наш контент (<div id="getting-started"><% content %></div>)
`<% content %> в layout'e это отрендеренный шаблон для данной страницы`
* так как у нас слои с обтеканием, мы делаем псевдослой для отключения обтекания со всех сторон чтобы не испортить наш `footer` (<div style="clear: both"></div>)
`На этом page закончился`
* `footer` у нас уже есть, в нем оставим все тоже что показывалось в Dancer'е, нас это устраивает

# Код в main.tt (пишем код <body></body>)
```
<body>
	<div id="page">
		<div id="sidebar">
			<ul id="sidebar-items"></ul>
		</div>
		<div id="content">
			<div id="header">
				<h1><a href="/">Fast Paste</a></h1>
				<h2>Welcome!</h2>
			</div>
			<div id="getting-started"><% content %></div>
			<div style="clear: both"></div>
		</div>
	</div>
	<div id="footer">Powered by <a href="http://perldancer.org/">Dancer2</a> <% dancer_version %></div>
</body>
```
`Таким образом будет выглядеть наш layout`

--------------------- (14:25) 
После того как мы создали layout, можно приступить к главной странице.
Главная страница у нас хранится опять таки во views/, открываем views/index.tt
# vim views/index.tt
И видим здесь много всего, большая часть из этого нам не надо, а скорее всего нам практически все не надо.

Но пока начнем писать своё
* озаглавим нашу формочку, заходя на главную пользователь должен видеть форму для отправки нового текста, `New Fast Paste` озаглавили нашу формочку.
* для того чтобы мы могли писать какие-то стили для нашей формы, если она нам не понравится по внешнему виду добавим ей `class` `id` `name`, она будет отправляться методом post, `ну и было бы очень неплохо защититься от двойного клика, например когда пользователь нажимает несколько раз на кнопочку или например тупит интернет он не видит отправилось или нет и он будет тыкать на эту кнопку столько раз сколько сможет,` так как у нас без авторизации и мы не уникализируем отправленные нам тексты, чтобы не забить нашу базу одинаковыми текстами защитимся от этого посредством написания javascript который заблокирует кнопочку отправить(`submit`), т.е. мы её сначала отключаем(disabled) 
* и затем чтобы пользователь хотябы понимал что происходит мы возьмем эту же кнопочку и в её значение напишем например 'Posting...'
`Таким образом если пользователь нажал на кнопку, она сразу же заблокируется, т.е. станет серенькой, недоступной для нажатия, а на кнопке будет написано 'Posting...', т.е. идет отправка информации`
Что у нас должно быь в форме:
* В форме у нас должна быть наша `textarea` обязательно, положим её тоже в некоторый слой чтобы можно было применять к нему стили через css, и имя(name="textpaste") которое указано внутри textarea говорит нам о том что после отправки запроса на сервер из браузера на сервер прилетит текст в параметре `textpaste`, т.е. с таким именем которое указано в самой `textarea`. Зададим у него 15 колонок(rows) сразу и если нам запостят сильно большие строки мы сделаем style="overflow: hidden; word-wrap: break-word; resezi: none; height: 400px;" чтобы наша форма выглядела красиво и не смущала пользователя, сразу же отключим изменение размера и укажем высоту примерно 400px(пикселей), не знаю, хорошо или плохо, много или мало, но будем считать что достаточно. Закроем наш `textarea`.
`Все, основное поле в форме готово. Приступим к дополнительным полям, т.е. к настройкам отправки этой текстовой информации. Все стили которые я использую это как правило стили из Dancer'a, я их уже не много помню `
* Класс form_frame_left говорит о том что это будет обтекаемым слева div, внутри которого мы будем писать уже свой контент, сделаем сразу и ему размер в 400px дабы наша форма при изменении размера окна браузера не менялась.
* Далее колонки, левая часть формы и правая часть формы(<div class="form_frame">), одна для expiration, это время которое будет нужно хранить, потом будет title, и в конце в этой же формочке будет кнопка.
* Внутри `Paste Expiration` у нас будет `Select` с выбором, т.е. не просто `input` в который можно что-то написать, а выпадающая менюшка, так у селекта надо сделать `name` это у нас будет `expire`, такое же имя будет приходить нам на сервер, будем считать что если отправлен 0, это значит что время хранения бесконечное, более чем 365 дней хранить не будем, считаем что это и так бесконечность, т.к. мы не знаем проживет ли наш проект впринципе столько времени.
* Внутри `Paste name` у нас будет просто <input type="text" name="title">, максимальную длину установим 60, с запасом, так чтобы базе данных точно хватило, чтобы `input` выглядел красиво сразу назначим ему некоторый класс Dancer'а `class="post_input"`
* Дальше у нас будет кнопочка, в название(<div class="form_left">) ничего мы не пишем, <input type="submit" name="submit" value="New Fast Paste" id="submit">, `id` нам нужен для javascript чтобы её отключить и поменять там `value`
`Все, div'ы закончились, форма закончилась. Можно считать что мы написали все что было нужно, и все что было нам не нужно.`

# Код в index.tt (пишем код в начало)
```
<h3>New Fast Paste</h3>
<form class="paste_form" id="pasteform" name="pasteform" method="post" onsubmit="
  document.getElementById('submit').disable=true; 
  document.getElementById('submit').value='Posting...';
">
	<div class="textarea_paste">
		<textarea name="textpaste" class="paste_textarea" rows="15" style="overflow: hidden; word-wrap: break-word; resezi: none; height: 400px;"></textarea>
	</div>
	<div class="content_title">Paste settings</div>
	<div class="form_frame_left" style="width:400px; min-width:400px;">
		<!-- expiration field -->
		<div class="form_frame">		<!-- колонка -->
			<div class="form_left">Paste Expiration</div>	<!-- строка -->
			<div class="form_right">
			<select name="expire">
				<option value="0">Never</option>
				<option value="600">10 min</option>
				<option value="3600">1 hour</option>
				<option value="86400">1 day</option>
				<option value="604800">1 week</option>
				<option value="31536000">365 day</option>
			</select>
			</div>
		</div>
		<!-- title field -->
		<div class="form_frame">
			<div class="form_left">Paste name</div>
			<div class="form_right"><input type="text" name="title" size="20" maxlength="60" value="" class="post_input"></div>
		</div>
		<!-- submit button -->
		<div class="form_frame">
			<div class="form_left">&nbsp;</div>
			<div class="form_right"><input type="submit" name="submit" value="New Fast Paste!" id="submit"></div>
		</div>
	</div>
</form>
```
`Вот так вот вяглядит наш шаблон. Я думаю ничего более хитрого тут делать пока не нужно. Этого нам для начала хватит, если что-то не понравится тогда будем переделывать`

---------------------- (20:00)
Ну давайте смотреть пока на перловый код, открываем lib/fastpaste.pm который Dancer сгенерировал.
# vim lib/fastpaste.pm
Видим что тут в общем то ничего хитрого нету кроме одного контроллера, который отрабатывает главню страницу и только методом get, рендерит он шаблон index, ну а layout он использует defaul который там указан.

Итак, что мы можем сделать на данный момент
Ну давайте мы запустим наше приложение и посмотри как оно выглядит на текущий момент. 
Запускаем мы его через `plackup` как я и говорил на лекции, скрипт для запуска который работает по протоколу .psgi лежит в папке bin
# plackup bin/app.psgi
Соответственно открываем браузер, вот наше приложение, у нас есть логотип Dancer'a(пока ничего не меняем если надо изменим), у нас есть название, есть приветствие которые мы написали и естественно `New Fast Paste` `textarea` и настройки.

Все отлично, наш модуль из 3-х строк кода уже что-то умеет делать и есть куча верстки.
Давайте напишем теперь метод, который будет обрабатывать `post` на '/', соответственно это метод отправки новой текстовой информации.
Что наш `post` должен делать:
* Для начала прочитаем все наши параметры, это наш новый текст(`text`) непосредственно, это название(`title`), еще у нас может прилетать `expire` (точнее он прилетает всегда, но иногда он равен 0).
* Наверное было бы неплохо провалидировать данные которые нам пришли, но давайте мы этот момент упустим и напишем сейчас тут # ToDo validate params
`Будем считать что все данные нам приходят верно, дабы отладить основной механизм работы приложения.`
* Далее запишем `create_time` время создания (время прихода запроса на сервер). 
* Далее было бы неплохо посчитать `expire_time`, это наш `create_time + expire`, однако если `expire` к нам не пришёл это не значит что `expire_time` будет равен `create_time`, поэтому проверяем что если `expire` к нам прилетел то `expire_time` = `create_time + expire` иначе это будет у нас `0`, а еще лучше `undef`, чтобы в базе был `NULL`, потому что в datetime если указать 0, это будет время начала эпохи (1970 год в mysql) Поэтому пусть лучше там лежит `undef`.
* Мы забыли подключить наш плагин `Dancer2::Plugin::Database`, соответственно после этого мы сможем пользоваться нашей базой данных, еще на всякий случай подключим `utf8`, остальное по ходу дела.
* Подготовим наш запрос к выполнению, `database` это функция которая экспортируется plugin'ом, она предоставляет интерфейс к DBI с небольшой обёрткой, запрос у нас будет сложный, поэтому никаких обёрток, пишем запрос на прямую, значит мы делаем `INSERT INTO paste (id, create_time, expire_time, title) VALUES (?,?,?,?);`
* а теперь немного хитрости, теоретически нам нужно было бы написать `4 знака ?`, т.е. 4 placeholder'а в которые будут подставляться параметры и экранироваться, для того чтобы не было уязвимости `SQL-injection` однако мы используем `bigint` а это увы `signed 64`(знаковое число), а `id` которые му будем генерировать они будут беззнаковыми, поэтому перед тем как нам его вставить, нам надо средствами mysql преобразовать в signed variant(знаковый вариант) -> `INSERT INTO paste (id, create_time, expire_time, title) VALUES (cast(? as signed),?,?,?);`
* второй нюанс, то что когда мы работаем с временем в базе данных оно подразумевает текстовое представление и никак не `unix-time`(количество секунд), и так как у нас время количество секунд, нам его надо тоже преобразовать во что-то понимаемое mysql'ем -> `INSERT INTO paste (id, create_time, expire_time, title) VALUES (cast(? as signed),from_unixtime(?),from_unixtime(?),?);`
`Ну и title vы передаем как есть, никуда нам его преобразовывать не надо.`

* Соответственно дальше давайте попробуем посчитать наш id'шник, crc64 экспортируется модулем `Digest::CRC`, crc64 как я говорил ранее считать мы будем -> crc64($text.$create_time)
Однако может так случиться что, произойдет коллизия(т.е. какое-то сочетание $text и $create_time или например в одну и туже секунду запостится один и тот же текст приведет к получению одинакового `crc64`). Для этого мы сделаем некоторый циклик, в котором мы будем считать и каким-то образом изменять наш текст от которого мы считаем `сrc64`, так как обратно нам ничего расшифровывать не надо и нам нужно это только для `генерации уникальной ссылки`, поэтому мы можем себе позволить сделать тут все что угодно. Говорим что наш `id` равен пустой строке, дальше в цикле while(!$id), т.е. пока не подсчитали id-шник, в `сrc64` приконкатенируем еще и id'шник, изначально это пустая страка, а затем если это `id` будет с коллизией мы его приконкатенируем к исходному тексту и времени и еще раз подсчитаем `сrc64`, который скорее всего уже будет без коллизии. 
* Однако мы не можем полагаться на то что таким образом мы не насутпим на коллизию множество раз поэтому давайте сразу же сделаем `try_count`, т.е. будем пытаться считать только 10 раз, и если уже мы посчитали 10 раз и все равно не нашли `id`, которого у нас нет, то выйдем из этого цикла, при этом скажем в этом случае что `id = undef`, чтобы за циклом можно было проверить уткнулись мы по ограничения по `try_count` или не уткнулись.
* Также мы будем проверять существует ли у нас такой id'шник или нет, все очень просто, файлы в которые мы будем помещать текст будем именовать теми же самыми id'шниками, соответственно мы проверяем наличие файла, для того чтобы проверить наличие файла давайте для начала сделаем sub'у (`get_upload_dir`), которая будет нам возвращать путь к директории в которой будут хранится все наши тексты, для нчала эта sub'а у нас не будет делать ничего, кроме как возвращать `config->{appdir} . '/paste/'`, директория в которой находится наше приложение и где мы создали папку `paste`, её мы и будем возвращать.
* Такие вещи я cразу же люблю делать отдельно, еще мне кажется было бы очень неплохо сделать вот так (my $upload_dir = 'paste'), `paste` положить в некоторую переменную, потом это будет проше поддерживать, если у нас что-то, как-то будет меняться, соответственно мы конкатенируем наш `config->{appdir}` с нашим `upload_dir`, который является папкой `paste`.
* Соответственно как же мы будем проверять существует или нет файл, а просто, мы берем `get_upload_dir` и конкатенируем с полученным `id`, таким образом если же у нас файлик такой уже есть мы будем также крутиться в этом цикле, причём крутиться 10 раз, пока не установим $id в undef. На самом деле код в цикле я не правильно написал, на самом деле мы сначала проверяем не закочились ли у нас итерации, потом считаем новый id'шник. 

* К тому же кроме существования файла нам еще нужно проверить нет ли записи в базе данных, мало ли кто успел записать в базу данных и не успел создать файл или сделать наоборот, дабы не произошло и такой коллизии мы сделаем попытку записи этого id'шника в базу данных, соответственно у нас есть подготовленный запрос, это наш `sth`, мы его запустим с параметром, наш сгенерированный новый `id`, дальше у нас есть `create_time`, потом `expire_time` и `title`, собственно `title` может прийти пустым поэтому я бы сделал тут вот так(my $title = params->{title}||'';), нужно обратить внимание что последовательность переданных параметров должна являться последовательностью знаков вопросов указанных `placeholder` при `prepare`.
* Следовательно если нам удалось записать эту запись в базу данных это значит что `execute` нам вернет `1`, в противном же случае он вернет `0`, поэтому проверим, удалось нам его записать или нет, т.е. если у нас не прошла попытка записи файлика(метаданных) в базу, то `id` присвоим `undef`, соответственно мы сбросим его. 
Мы его посчитали, попытались записать в базу, в базу записать не смогли из-за того что данный `id` уже есть, сбросили его, для того чтобы на следующей итерации while'a еще раз посчитать новый id'шник и опять его попытаться записать, если же у нас получилось записать `id` в базу это значит что он будет определен, мы зайдем на следующую итерацию, если файлика такого у нас нету еще то мы больше в цикл не зайдем, если же файлик такой есть, то наверняка нам `надо бы удалить записанную запись в базу`, но это только в том случае если у нас есть `id` посчитанный на предыдущей итерации, сделаем постфиксную запись (операция if условие;), сделаем DELETE.
* у нас выполнится данный цикл, и нам нужно проверить, есть ли у нас наш `id` (не стал ли он в цикле = `undef`) и смогли ли мы его посчитать или уперлись в `try_count`, то мы временно ставим `die попробуйте позже`, как формировать правильно ошибки я покажу несколько позже, пока делаем заглушки и считаем что данные у нас приходят правильно и не на какие коллизии мы не наступаем чтобы отладить механизм сохранения.

---------------------- (37:20)
* Соответственно объявляем наш файловый дескриптор, скаляр для работы с файликами, проверяем что нам удалось открыть на запись наш новый файлик, если же не удалось мы пишем `die Internal error: $!`, т.е. что-то пошло не так
---------------------- (38:01)

# Код lib/fastpaste.pm 
```
package fastpaste;
use utf8;
use Dancer2;
use Dancer2::Plugin::Database;
use Digest::CRC qw(crc64);

our $VERSION = '0.1';

my $upload_dir = 'paste';

sub get_upload_dir {
	return config->{appdir} . '/' . $upload_dir . '/';
}

get '/' => sub {
    template 'index';
};

post '/' => sub {
	my $text = params->{textpaste};		# текст 
	my $title = params->{title}||'';	# заголовок(название)
	my $expire = params->{expire};		# время жизни (0 = бесконечно)

	# ToDo validate params

	my $create_time = time();		# время создания (время прихода запроса на сервер)
	my $expire_time = $expire ? $create_time + $expire : undef;

	my $sth = database->prepare('INSERT INTO paste (id, create_time, expire_time, title) VALUES (cast(? as signed), from_unixtime(?), from_unixtime(?), ?);');

	my $id = '';
	my $try_count = 10;
	while (!$id or -f get_upload_dir.$id) {	# если id (undef,'') или существует файл то входим
		database->do('DELETE FROM paste WHERE id = cast(? as signed);', {}, [$id]) if $id;	# если id не (undef,'')(т.е. добавили в бд успешно, но файл уже существовал),то удаляем сделанную запись
		unless (--$try_count) {	# если превышен лимит попыток добавления
			$id = undef;
			last;
		}
		$id = crc64($text.$create_time.$id);
		$id = undef unless $sth->execute($id, $create_time, $expire_time, $title);	# если добавление не удалось (id уже есть в базе)
	}
	unless ($id) {	# если id в итоге стал undef (не удалось за 10 проходов)
		die 'Try latter';
	}

	my $fh;
	unless (open($fh, '>', get_upload_dir.$id)) {
		die 'Internal error '.$!;
	}
	print $fh $text;
	close($fh);

	redirect '/' . unpack 'H*', pack 'Q', $id;
};

true;
```


----------------------


----------------------


































