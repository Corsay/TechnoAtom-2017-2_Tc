#!/usr/bin/env perl

use 5.016;
use warnings;

use DDP;
use Data::Dumper;
use Getopt::Long;

# хеш наличия параметра у ключа
# undef - ключ не нужен
my %keysvalues = (
	"-k" => '0',	# указание колонки для сортировки (ожидает параметр - номер колонки)
	"-n" => undef,	# сортировать по числовому значению (<=>), по-умолчанию (cmp)
	"-r" => undef,	# сортировать в обратном порядке ($b $a), по-умолчанию ($a $b)
	"-u" => undef,	# не выводить повторяющиеся строки
);

# в @line будем иметь строки сортируемого текста
my @line;

# в @ARGV имеем ключи их параметры и названия файлов для открытия (ну и мусор вызывающий ошибки)
# помещаем ключи и параметры в хеш ключей сортировки
my %sortkeys;
$i = 0;
while ($i < @ARGV) {
	# считываем параметр
	my $key = $ARGV[$i];
	# если является допустимым ключом
	if (exists $keysvalues{$key}) {
		$sortkeys{$key} = undef;	# для большинства ключей параметр не нужен
		if (defined $keysvalues{$key}) {	# проверяем, нужен и передан ли параметр
			$i++;
			die "Ключ '$key' должен использоваться с аргументом" if ($i >= @ARGV);
			# считываем параметр
			my $param = $ARGV[$i];
			# проверяем параметр
			
			# записываем параметр в хеш ключей сортировки
			$sortkeys{$key} = $param;
		}
	}
	else {
		# если является не ключом - то это либо ошибка, либо файл для считывания

		# выведем ошибку - ввод некорректного ключа или ввод параметра после ключа который его не требует
		die "Неверный ключ '$key'";
	}
	$i++;
}

p %sortkeys;

# если @line к этому моменту пуст(не передали ни одного файла), то читаем стандартный ввод
my $i = 0;
while (<STDIN>) {
	chomp;	# отсекаем \n
	@line[$i++] = $_;
}
#say Dumper \@line;
#p @line;

# отступ
say "";

# еcли массив пустой (допустим пользователь передал пустой файл или не передал вовсе введя вручную сtrl+D ) 
die "Нечего сортировать" unless @line; 

#
# my $type = sub { cmp };
# my $sort = sub {$a $type $b};

# Дальше сортируем согласно переданным аргументам
my @sortedLine;
if (@ARGV) {
	# обрабатываем поочередно параметпы
	# -k
	# -n
	# -r
	# -u
	for $i (0..@ARGV) {

	}
}
else {
	# просто сортируем (лексикографически по возрастанию)
	@sortedLine = sort {$a cmp $b} @line;
}

#p @sortedLine;

# вывод отсортированного массива
for my $line (@sortedLine) {
	say $line;
}